# Inhaltsverzeichnis

## 1. Einleitung
   - 1.1 Motivation
## Motivation

Die vorliegende Arbeit fokussiert sich auf die Entwicklung eines Prototyps für den "Haushaltsplangenerator" im Kontext meines ehrenamtlichen Amtes als "Finanzer der Studierendenvertretung" innerhalb der Dualen Hochschule Baden-Württemberg. 

Als verantwortliche Person für die Erstellung und Präsentation regelmäßiger Haushaltspläne vor dem Studierendenparlament bin ich zunehmend erschöpft und entmutigt durch die mühsame Nutzung von Excel als primärem Werkzeug für diese Aufgabe. 

Die Notwendigkeit, komplexe finanzielle Informationen in einer unübersichtlichen Tabellenkalkulation zu verwalten, birgt diverse Herausforderungen, die einen zeit- und ressourcenaufwändigen Prozess darstellen.

Vor diesem Hintergrund zielt diese Arbeit darauf ab, einen innovativen und effizienten Ansatz zu präsentieren, indem ein speziell konzipierter "Haushaltsplangenerator" als alternative Lösung entwickelt wird. 

Die Entscheidung, einen Prototypen mit einem Schwerpunkt auf dem Backend zu erstellen, ist darauf zurückzuführen, dass die Funktionalität und Datenverarbeitung im Backend einen wesentlichen Einfluss auf die Effizienz und Genauigkeit der Haushaltsplanung haben. 

Hierbei wird der Fokus auf die Implementierung einer angenehmen dedizierten Webanwendung gelegt, die eine übersichtliche und benutzerfreundliche Oberfläche zur Verfügung stellt, um den mühsamen Prozess der Haushaltsplanung zu vereinfachen.

Der Wunsch nach einem dedizierten "Haushaltsplangenerator" ergibt sich aus der Notwendigkeit, die Haushaltsplanung zu optimieren und dabei menschliche Fehlerquellen zu minimieren. 

Die Integration von Design Patterns wie dem Observer Pattern und dem Factory Pattern wird dazu beitragen, die Flexibilität, Erweiterbarkeit und Wartbarkeit der Anwendung zu erhöhen, während Domain Driven Design (DDD) und Clean Architecture den klaren Fokus auf eine gut strukturierte und an die Domäne angepasste Softwarearchitektur legen.

Die Anwendung dieses Prototyps als praktische Lösung in meinem ehrenamtlichen Amt soll nicht nur meine persönliche Arbeitsbelastung verringern, sondern auch als Proof-of-Concept dienen, der anderen Studierendenvertretungen oder vergleichbaren Organisationen als Modell dienen kann. 

Dabei werden die Konzepte und Prinzipien der Programmierung sowie der Einsatz von Entwurfsmustern und Unit Tests in einem realen Anwendungskontext verifiziert.

Abschließend wird der angestrebte Prototyp des "Haushaltsplangenerators" auf eine solide Grundlage gestellt, um in zukünftigen Projekten weiterentwickelt und verfeinert zu werden. 

Durch die Umsetzung eines strukturierten, flexiblen und effizienten Haushaltsplanungssystems werden nicht nur meine Arbeitsabläufe optimiert, sondern auch die Effektivität und Transparenz der finanziellen Ressourcenverwaltung in der Studierendenvertretung erheblich verbessert.


   - 1.2 Zielsetzung
   - 1.3 Aufbau der Arbeit

## 2. Theoretische Grundlagen
   - 2.1 Domain Driven Design (Verwendung begründen)
   - 2.2 Clean Architecture (Verwendung begründen)
   - 2.3 Programming Principles (Verwendung begründen)

## 3. Motivation und Einleitung zum Praxisprojekt: Haushaltsplangenerator
   - 3.1 Beschreibung des Projektkontexts
   - 3.2 Integration der erlernten Konzepte und Prinzipien
   - 3.3 Herausforderungen und Lösungsansätze

## 4. Analyse und Design
   - 4.1 Anforderungsanalyse
   - 4.2 Architekturdesign
      - 4.2.1 Schichtarchitekturplanung und Begründung
      - 4.2.2 Entwurf der Domain-Schicht
      - 4.2.3 Entwurf der Infrastruktur-Schicht
   - 4.3 Design Patterns
      - 4.3.1 Observer Pattern (Einsatz und Begründung)
      - 4.3.2 Factory Pattern (Einsatz und Begründung)

## 5. Implementierung
   - 5.1 Umsetzung der Schichtenarchitektur
   - 5.2 Implementierung der Domain-Logik
   - 5.3 Einbindung von externen Datenquellen
   - 5.4 Unit Testing (Einsatz und Begründung von Unit Tests und Mocks)

## 6. Refactoring und Qualitätssicherung
   - 6.1 Identifikation von Code Smells
   - 6.2 Durchführung von Refactoring-Maßnahmen
   - 6.3 Begründung der angewendeten Refactorings
   - 6.4 Code-Qualität und Code Reviews

## 7. Zusammenfassung und Ausblick
   - 7.1 Zusammenfassung der Ergebnisse
   - 7.2 Ausblick und mögliche Erweiterungen

## 8. Literaturverzeichnis

## 9. Anhang
   - 9.1 Glossar
   - 9.2 Quellcodebeispiele
   - 9.3 Testfallbeschreibungen
